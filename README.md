# ê³„ì‚°ê¸°ğŸ”¢

## ëª©ì°¨
1. [ì†Œê°œ](#1-ì†Œê°œ)
2. [íŒ€ì›](#2-íŒ€ì›)
3. [íƒ€ì„ë¼ì¸](#3-íƒ€ì„ë¼ì¸)
4. [í”„ë¡œì íŠ¸ êµ¬ì¡°](#4-í”„ë¡œì íŠ¸-êµ¬ì¡°)
5. [ì‹¤í–‰í™”ë©´(ê¸°ëŠ¥ ì„¤ëª…)](#5-ì‹¤í–‰-í™”ë©´ê¸°ëŠ¥-ì„¤ëª…)
6. [íŠ¸ëŸ¬ë¸”ìŠˆíŒ…](#6-íŠ¸ëŸ¬ë¸”-ìŠˆíŒ…)
7. [ì°¸ê³ ë§í¬](#7-ì°¸ê³ -ë§í¬)
8. [ì•„ì‰¬ìš´ì ](#8-ì•„ì‰¬ìš´-ì )

<br/>

## 1. ì†Œê°œ
ìˆ«ìì™€ ì—°ì‚°ìë¥¼ í„°ì¹˜í•˜ì—¬ ê³„ì‚°ì„ ì§„í–‰í•  ìˆ˜ ìˆëŠ” ì–´í”Œì…ë‹ˆë‹¤. 


<br/>

## 2. íŒ€ì›

|â­ï¸Rhode|
| :--------: | 
|<img height="210px" src="https://i.imgur.com/XyDwGwe.jpg">|
|ê·¸ë ‡ì§€ë§Œ ì–´ì©Œê² ìŠµë‹ˆê¹Œ í•´ë‚´ì•¼ì£ |



</br>

## 3. íƒ€ì„ë¼ì¸
### í”„ë¡œì íŠ¸ ì§„í–‰ ê¸°ê°„
**23.01.24 (í™”) ~ 23.01.27 (ê¸ˆ)** 

|ë‚ ì§œ|íƒ€ì„ë¼ì¸|
| :-------: | ------- |
|01.24 (í™”) | **STEP01**: CalculatorTests ìœ ë‹› í…ŒìŠ¤íŠ¸ êµ¬í˜„, CalculatorItemQueue êµ¬í˜„ |
|01.25 (ìˆ˜) | **STEP01**: dequeueì™€ enqueueì— ëŒ€í•œ í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ ì¶”ê°€, PR |
|01.26 (ëª©) | **STEP01**: dataí”„ë¡œí¼í‹° ìˆ˜ì •, isEmptyë©”ì„œë“œ í”„ë¡œí¼í‹°ë¡œ ìˆ˜ì •, **STEP01 Merge** |
|01.27 (ê¸ˆ) | **STEP02**: Operator ì—´ê±°í˜•, ExpressionParser ì—´ê±°í˜•, Formula êµ¬ì¡°ì²´ í‹€ êµ¬í˜„, OperatorTests ìœ ë‹› í…ŒìŠ¤íŠ¸ êµ¬í˜„ |
| 01.29 (ì¼) | **STEP02**: FormulaTests ìœ ë‹› í…ŒìŠ¤íŠ¸ êµ¬í˜„, Formula êµ¬ì¡°ì²´ êµ¬í˜„, String ìµìŠ¤í…ì…˜ êµ¬í˜„, ExpressionParserTests ìœ ë‹› í…ŒìŠ¤íŠ¸ êµ¬í˜„ |
| 01.30 (ì›”) | **STEP02**: ExpressionParser ì—´ê±°í˜• êµ¬í˜„, FormulaTests ìœ ë‹›í…ŒìŠ¤íŠ¸ ì¶”ê°€, Operator rawValue UIì— ìˆëŠ” ê°’ìœ¼ë¡œ ìˆ˜ì • |
|01.24 (í™”) | **STEP02 Merge**, **STEP03**:  |
|01.25 (ìˆ˜) | **STEP03**:  |
|01.26 (ëª©) | **STEP03**:  |
|01.27 (ê¸ˆ) | **STEP03**:  |

<br/>

## 4. í”„ë¡œì íŠ¸ êµ¬ì¡°
### í´ë˜ìŠ¤ ë‹¤ì´ì–´ê·¸ë¨

|STEP01|STEP02|
| :--------: | :--------: |
|<img height="500px" src="https://i.imgur.com/b4dEFJN.png">| <img height="500px" src="https://i.imgur.com/PUf6yZm.png"> |


<br/>

## 5. ì‹¤í–‰ í™”ë©´(ê¸°ëŠ¥ ì„¤ëª…)
ì´í›„ STEPì—ì„œ ì¶”ê°€ ì˜ˆì •

</br>

## 6. íŠ¸ëŸ¬ë¸” ìŠˆíŒ…
### 1. STEP01: CalculatorItemQueueë¥¼ structë¡œ êµ¬í˜„í•˜ëŠ” ê²ƒì´ ì˜³ì€ê°€?
ë‹¤ìŒê³¼ ê°™ì€ ì´ìœ ë¡œ `CalculatorItemQueue`ì„ structë¡œ êµ¬í˜„í–ˆìŠµë‹ˆë‹¤.

ê°’ì„ ì°¸ì¡°í•´ì•¼í•˜ëŠ” ê²½ìš° classë¡œ êµ¬í˜„í•˜ëŠ” ê²ƒì„ ê¶Œì¥í•œë‹¤.
ìƒì†ì„í•´ì•¼í•˜ëŠ” ê²½ìš° classë¡œ êµ¬í˜„í•˜ëŠ” ê²ƒì„ ê¶Œì¥í•œë‹¤.
íƒ€ì…ìºìŠ¤íŒ…ì„ ì‚¬ìš©í•´ì•¼í•˜ëŠ” ê²½ìš° classë¡œ êµ¬í˜„í•˜ëŠ” ê²ƒì„ ê¶Œì¥í•œë‹¤.
ìœ„ ì„¸ê°€ì§€ì˜ ì´ìœ ê°€ ì•„ë‹ˆë¼ë©´ ì¼ë°˜ì ìœ¼ë¡œ structë¡œ êµ¬í˜„í•˜ëŠ” ê²ƒì„ ì• í”Œì˜ guidelineì—ì„œëŠ” ê¶Œì¥í•œë‹¤.
ì°¸ì¡°, ìƒì†, íƒ€ì…ìºìŠ¤íŒ… ëª¨ë‘ ì‚¬ìš©í•  ì¼ì´ ì—†ì–´ì„œ structë¡œ êµ¬í˜„í•˜ëŠ” ê²ƒì´ ë§ë‹¤ê³  íŒë‹¨í–ˆìŠµë‹ˆë‹¤. 

### 2. STEP02: 0ìœ¼ë¡œ ë‚˜ëˆ„ì—ˆì„ ê²½ìš° nanì„ ë°˜í™˜í•˜ëŠ” ê²ƒì— ëŒ€í•´ì„œ í…ŒìŠ¤íŠ¸í•˜ê¸°

```swift
func test_Operatorê°€devideì´ê³ 3ê³¼0ì´ì£¼ì–´ì¡Œì„ë•Œ_calculateí˜¸ì¶œì‹œ_NaNì„ë°˜í™˜í•œë‹¤() {
    //given
    let lhs = 3.0
    let rhs = 0.0
    sut = Operator.devide
    let expectedValue = Double.nan
    //when
    let result = sut.calculate(lhs: lhs, rhs: rhs)
    //then
    XCTAssertEqual(expectedValue, result)
}
```
ìœ„ì™€ ê°™ì´ í…ŒìŠ¤íŠ¸ë¥¼ ì§„í–‰í•˜ì˜€ê³ , "nan"ê³¼ "nan"ì´ ì¼ì¹˜í•˜ì§€ ì•ŠëŠ”ë‹¤ëŠ” ë¬¸ì œê°€ ë‚˜ì™”ìŠµë‹ˆë‹¤.

ê³µì‹ë¬¸ì„œë¥¼ í†µí•´ì„œ, nanì¸ì§€ ì—¬ë¶€ë¥¼ í™•ì¸í•˜ëŠ” ê²ƒì€ Equalë¡œ ì ‘ê·¼í•´ì•¼í• ê²Œ ì•„ë‹ˆë¼ isNaNìœ¼ë¡œ ì ‘ê·¼í•´ì•¼í•œë‹¤ëŠ” ê²ƒì„ ì•Œì•˜ìŠµë‹ˆë‹¤.

> Because a NaN always compares not equal to itself, to test whether a floating-point value is NaN, use its isNaN property instead of the equal-to operator (==). In the following example, y is NaN.
> ```swift
> let y = x + Double.nan
> print(y == Double.nan)
> // Prints "false"
> print(y.isNaN)
> // Prints "true"
> ```

```swift
func test_Operatorê°€devideì´ê³ 3ê³¼0ì´ì£¼ì–´ì¡Œì„ë•Œ_calculateí˜¸ì¶œì‹œ_NaNì„ë°˜í™˜í•œë‹¤() {
    //given
    let lhs = 3.0
    let rhs = 0.0
    sut = Operator.devide
    let expectedValue = Double.nan
    //when
    let result = sut.calculate(lhs: lhs, rhs: rhs)
    //then
    XCTAssertTrue(result.isNaN)
}
```

ê·¸ë˜ì„œ ìœ„ì™€ ê°™ì´ í…ŒìŠ¤íŠ¸ë¥¼ ê³ ì³¤ê³  ì •ìƒì ìœ¼ë¡œ í™•ì¸ì´ ë©ë‹ˆë‹¤.

### 3. STEP02: componentsByOperators ë¦¬íŒ©í† ë§í•˜ê¸°

**ì½”ë“œ01**
<details>
<summary>ì½”ë“œë³´ê¸°</summary>
    
```swift
private static func componentsByOperators(from input: String) -> [String] {
    let componentsByAdd: [String]
    var componentsBySubtractTwo: [[String]] = []
    var componentsByMultiplyTwo: [[String]] = []
    var componentsByDevideTwo: [[String]] = []
    
    componentsByAdd = input.split(with: Operator.add.rawValue)
    
    for component in componentsByAdd {
        componentsBySubtractTwo.append(component.split(with:
Operator.subtract.rawValue))
    }
    let componentsBySubtract = componentsBySubtractTwo.flatMap { $0 }
    
    for component in componentsBySubtract {
        componentsByMultiplyTwo.append(component.split(with:
Operator.multiply.rawValue))
    }
    let componentsByMultiply = componentsByMultiplyTwo.flatMap { $0 }
    
    for component in componentsByMultiply {
        componentsByDevideTwo.append(component.split(with:
Operator.devide.rawValue))
    }
    let componentsByDevide = componentsByDevideTwo.flatMap { $0 }
    
    return componentsByDevide
}
```
</details>
    
ê°€ì¥ ìµœì´ˆì˜ ì½”ë“œì…ë‹ˆë‹¤. ì¤‘ë³µë˜ëŠ” ì½”ë“œì™€ ë³€ìˆ˜ê°€ ë¶ˆí•„ìš”í•˜ê²Œ ë§ì•„ ì§€ì €ë¶„í•œ ìƒí™©ì´ì—ˆìŠµë‹ˆë‹¤.
<br/>

**ì½”ë“œ02**

<details>
<summary>ì½”ë“œë³´ê¸°</summary>

> ë°°ì—´ ë”í•˜ê¸°
> ```swift
> let ArrayA = [1, 23, 456]
> var ArrayB = [2, 34, 567]
>
> let ArrayC = ArrayA + ArrayB
> print(ArrayC)  //[1, 23, 456, 2, 34, 567]
> 
> ArrayB += ArrayA
> print(ArrayB)  //[2, 34, 567, 1, 23, 456]
> ````
> ìœ„ì™€ ê°™ì´ ë°°ì—´ì„ ë”í•´ì¤„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```swift
static func componentsByOperators(from input: String) -> [String] {
    let componentsByAdd: [String]
    var componentsBySubtract: [String] = []
    var componentsByMultiply: [String] = []
    var componentsByDevide: [String] = []
    
    componentsByAdd = input.split(with: Operator.add.rawValue)
    
    for component in componentsByAdd {
        componentsBySubtract += component.split(with:
Operator.subtract.rawValue)
    }
    
    for component in componentsBySubtract {
        componentsByMultiply += component.split(with:
Operator.multiply.rawValue)
    }
    for component in componentsByMultiply {
        componentsByDevide += component.split(with: Operator.devide.rawValue)
    }
    
    return componentsByDevide
}
```

</details>

ë°°ì—´ì„ ë”í•˜ê¸°ë¥¼ í†µí•´ í•©ì³ì¤„ ìˆ˜ ìˆë‹¤ëŠ” ì ì„ ì•Œê²Œ ë˜ì–´ì„œ ê·¸ ì ì„ ì´ìš©í•´ë³´ì•˜ìŠµë‹ˆë‹¤.

<br/>

**ì½”ë“œ03**

```swift
static func componentsByOperators(from input: String) -> [String] {
    var componentsByOperators = [input]
    
    for operateSymbol in Operator.allCases {
        var temporaryComponents: [String] = []
        for component in componentsByOperators {
            temporaryComponents += component.split(with:
operateSymbol.rawValue)
        }
        componentsByOperators = temporaryComponents
    }
    
    return componentsByOperators
}
```
`operator`ê°€ caseIterableì¸ ì ì„ ì´ìš©í•´ì„œ forë¬¸ì„ ì‚¬ìš©í•´ì„œ ë” ê°„ë‹¨í•˜ê²Œ ë§Œë“¤ì–´ë³´ì•˜ìŠµë‹ˆë‹¤.


### 4. STEP02: ì£¼ì–´ì§„ Stringì„ ì—°ì‚°ìë¥¼ ê¸°ì¤€ìœ¼ë¡œ ë¶„ë¦¬í•˜ê¸°

ì—°ì‚°ìë¥¼ ê¸°ì¤€ìœ¼ë¡œ ë¶„ë¦¬í•˜ëŠ” ê¸°ëŠ¥ì—ì„œ ë§Œì•½, "1+2--3*4/5"ì´ë¼ë©´ -3ìœ¼ë¡œ ë¶„ë¦¬ë˜ì§€ ì•ŠëŠ” ë¬¸ì œê°€ ìƒê²¼ìŠµë‹ˆë‹¤. 
ì´ëŠ” `Operator`ì˜ rawValueë¥¼ í‚¤ë³´ë“œì— ìˆëŠ” ë§ˆì´ë„ˆìŠ¤ ì—°ì‚°ì(-)ë¥¼ ì‚¬ìš©í•´ì„œ ì§€ì •í•´ì£¼ì—ˆê¸° ë•Œë¬¸ì— ìƒê¸´ ë¬¸ì œì˜€ìŠµë‹ˆë‹¤. í”Œë ˆì´ ê·¸ë¼ìš´ë“œì—ì„œ í…ŒìŠ¤íŠ¸ í•´ë³¸ ê²°ê³¼ ë§ˆì´ë„ˆìŠ¤ ì—°ì‚°ì(-)ì™€ UIì— ìˆëŠ” ë§ˆì´ë„ˆìŠ¤ ê¸°í˜¸(âˆ’)ê°€ ë‹¤ë¥´ë‹¤ëŠ” ê²ƒì„ ì•Œê²Œë˜ì—ˆìŠµë‹ˆë‹¤.

ê·¸ë˜ì„œ `Operator`ì˜ rawValueë¥¼ ê¸°ì¡´ì˜ ê²ƒì—ì„œ UIì— ìˆëŠ” ê¸°í˜¸ë“¤ë¡œ ë°”ê¾¸ì—ˆìŠµë‹ˆë‹¤:
```swift
case add = "+"
case subtract = "âˆ’"
case divide = "Ã·"
case multiply = "Ã—"
```
ê·¸ëŸ¬ë©´ì„œ, í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ì˜ Stringì•ˆì— ìˆëŠ” ì—°ì‚°ì í‘œì‹œë“¤ë„ ìœ„ì™€ ê°™ì´ ë°”ê¾¸ì—ˆìŠµë‹ˆë‹¤. 
ì¶”ê°€ë¡œ ë‹¤ìŒì˜ í…ŒìŠ¤íŠ¸ ì½”ë“œë¥¼ ì‘ì„±í•˜ì—¬ ìŒìˆ˜ê°€ ë¶„ë¦¬ë˜ëŠ” ê²ƒì„ í™•ì¸í–ˆìŠµë‹ˆë‹¤:
```swift
func
test_inputì´1ë”í•˜ê¸°ë§ˆì´ë„ˆìŠ¤2ë¹¼ê¸°3ê³±í•˜ê¸°ë§ˆì´ë„ˆìŠ¤4ë‚˜ëˆ„ê¸°5ì¼ë•Œ_parseí˜¸ì¶œì‹œ_1ê³¼ë§ˆì´ë„ˆìŠ¤2ì™€3ê³¼ë§ˆì´ë„ˆìŠ¤4ì™€5ê°€ë“¤ì–´ìˆëŠ”ë°°ì—´ê³¼ë”í•˜ê¸°ë¹¼ê¸°ê³±í•˜ê¸°ë‚˜ëˆ„ê¸°ê°€ë“¤ì–´ìˆëŠ”ë°°ì—´ì˜íë¥¼ë°˜í™˜í•œë‹¤() {
    //given
    let input = "1+-2âˆ’3Ã—-4Ã·5"
    let expectedOperands = [1.0, -2.0, 3.0, -4.0, 5.0]
    let expectedOperator: [Operator] = [.add, .subtract, .multiply, .divide]
    
    //when
    let result = ExpressionParser.parse(from: input)
    
    //then
    XCTAssertEqual(expectedOperands, result.operands.data)
    XCTAssertEqual(expectedOperator, result.operators.data)
}
```


<br/>

## 7. ì°¸ê³  ë§í¬
> - [Swift ê³µì‹ë¬¸ì„œ - Generics](https://docs.swift.org/swift-book/LanguageGuide/Generics.html)
> - [Swift ê³µì‹ë¬¸ì„œ - forEach(-:)](https://developer.apple.com/documentation/swift/sequence/foreach(_:))


<br/>

## 8. ì•„ì‰¬ìš´ ì 
### STEP01
ë‹¤ë¥¸ ë¶„ë“¤ì€ ë§í¬ë“œë¦¬ìŠ¤íŠ¸ë¥¼ ë§ì´ ì‚¬ìš©í•˜ì‹  ê²ƒ ê°™ì€ë°, ì €ëŠ” ë§í¬ë“œë¦¬ìŠ¤íŠ¸ë¥¼ ì‚¬ìš©í•˜ì§€ ì•Šì•˜ë˜ ì ì´ ì¡°ê¸ˆ ì•„ì‰¬ì› ìŠµë‹ˆë‹¤.

### STEP02
for-inë¬¸ì´ ì•„ë‹Œ forEachë¥¼ ì‚¬ìš©í•´ë´¤ì–´ë„ ì¢‹ì•˜ì„ ê²ƒ ê°™ìŠµë‹ˆë‹¤. 


### STEP03
ì´í›„ STEPì—ì„œ ì¶”ê°€ ì˜ˆì •



